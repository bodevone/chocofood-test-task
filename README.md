# Тестовое Задание ChocoFood

Для начала работы в режиме разработки
```
docker-compose up --build
```

Для начала работы в режиме релиза
```
docker-compose -f docker-compose.prod.yml up --build 
```

## Алгоритм

Все работы для создания алгоритма были произведены в отдельной папке `algorithm`.

Алгоритм был реализован с помощью модели машинного обучения - Линейная Регрессия. Для этого была использована библиотке `scikit-learn` с ее классом `LinearRegression`.

Учитывая, что данные на входе это текст, то его надо как-то преоброзвать для работы с моделью. Для этого был использован токенизатор, который на основе принципа tf-idf приобразует слова в числа. Для этого была использована библиотека `keras` с ее классом `Tokenizer`.

Оба этих класса затем были приобразованы в бинарную форму с помощью стандартной библиотеки `pickle` и заново использованы уже на сервере.

## Django Приложение

REST сервис был реализован с помощью `Django-Rest-Framework`. Все связано вместе с помощью `docker-compose` и разделено на 2 среды: разработка (development) и релиз (production). Для работы с алгоритмом был создан отдельный класс `Algorithm`, который прогружает все бинарные файлы и готов принимать текст для предсказания рейтинга.

## 12 факторов

1. Кодовая база

Выполнен с помощью Git на Github

2. Зависимости

Выполнен с помощью `Dockerfile`, где скачиваются зависмости на уровне ОС для работы внутри контейнера, и `requirements.txt`, где указаны все необходмые зависимости для самого приложения

3. Конфигурация

Учитывая, что приложение написано для всех стадий кроме релиза, все конфигурации хранятся в файлах `docker-compose` в разделах `environment` для демонстрации их значений. В локальной разработке их можно хранить в файле `.env`, а на стадии релиза в секретных переменных самого провайдера

4. Сторонние службы

В этом приложении только один пример сторонней службы в виде датабазы `PostgreSQL`, который реалиозван с помощью отдельного контейнера. Он на самом деле здесь не нужен по скольку не хранит никаких данных, но интегрирован в целях демонстрации

5. Сборка, релиз, выполнение



6. Процессы

Учитвая что наше приложение приложение это просто REST сервис, то никакие данные состояний не хранятся

7. Привязка портов

Выполнен внутри файлов `docker-compose`, где указаны порты, где будет работать приложение и куда оно будет перенаправлено. Дальнейшие шаги в этой сфере могут включить добавленеи обратного прокси (reverse proxy) как `nginx` для дальнейшего пернаправления портов

8. Параллелизм

В данном случае нет необходимости добавлять другие процессы по типу фоновая задача, поскольку приложение выполняет только одну задачу, веб-процесс для обработки HTTP-запросов

9. Утилизируемость



10. Паритет разработки/работы приложения

Разработка (development) и работа (production) приложения схожы по всем пунктам кроме запуска, который в разработке реализован с помощью команды самого `Django` `python manage.py runserver`, а в случае работы он осуществлен с помошью `Gunicorn`.

11. Журналирование

Журналирование может быть доступно с помощью команды самого `Docker`-а `docker-compose logs`, который покажет события со всех контейнеров. Решения в релизе будут включать сторонние сервисы

12. Задачи администрирования

Эти задачи выполняются один раз при запуске приложения в конце файлов `Dockerfile` при помощи команды `ENTRYPOINT`, которые указывают на файлы `entrypoint`. Эти задачи включают в себя миграцию датабазы для обоих разработки и работы, а также сбор статических файлов в случае работы 