# Тестовое Задание ChocoFood

REST-сервис с алгоритмом для предсказания предпологаемого рейтинга пользователя на основе его отзыва


## Запуск

Для начала работы в режиме разработки
```
docker-compose up --build
```

Для начала работы в режиме релиза
```
docker-compose -f docker-compose.prod.yml up --build 
```

## Алгоритм

Все работы для создания алгоритма были произведены в отдельной папке `algorithm`.

Алгоритм был реализован с помощью модели машинного обучения - Линейная Регрессия. Для этого была использована библиотке `scikit-learn` с ее классом `LinearRegression`.

Учитывая, что данные на входе это текст, то его надо как-то преоброзвать для работы с моделью. Для этого был использован токенизатор, который на основе принципа tf-idf приобразует слова в числа. Для этого была использована библиотека `keras` с ее классом `Tokenizer`.

Оба этих класса затем были приобразованы в бинарную форму с помощью стандартной библиотеки `pickle` и заново использованы уже на сервере.

### `model.py`

Файл с тренировкой и созданием токенизтора. Эти классы сразу же сохранены тут в бинарную форму

### `predict.py`

Файл с предсказанием рейтинга. Все необходимые классы переведены из бинарной формы и готовы для работы. Входящие данные преобразуются с помощью токенизатора и затем предсказываются с помошью модели

## Django Приложение

REST сервис был реализован с помощью `Django-Rest-Framework`. Все связано вместе с помощью `docker-compose` и разделено на 2 среды: разработка (development) и релиз (production). Для работы с алгоритмом был создан отдельный класс `Algorithm`, который прогружает все бинарные файлы и готов принимать текст для предсказания рейтинга.

## 12 факторов

1. Кодовая база

Выполнен с помощью Git на Github

2. Зависимости

Выполнен с помощью `Dockerfile`, где скачиваются зависмости на уровне ОС для работы внутри контейнера, и `requirements.txt`, где указаны все необходмые зависимости для самого приложения

3. Конфигурация

Учитывая, что приложение написано для всех стадий без действительного релиза на сервер, все конфигурации хранятся в файлах `docker-compose` в разделах `environment` для демонстрации их значений. В локальной разработке их можно хранить в файле `.env`, а на стадии релиза в секретных переменных самого сервиса

4. Сторонние службы

В этом приложении только один пример сторонней службы в виде датабазы `PostgreSQL`, который реалиозван с помощью отдельного контейнера. Он на самом деле здесь не нужен по скольку не хранит никаких данных, но интегрирован в целях демонстрации. Все службы вне зависимости от местположения будут расценены одиноково, так же как эта датабаза

5. Сборка, релиз, выполнение

Был реализовано с помощью `TravisCI`, который начинает весь этот процесс после каждого коммита в репозитори. Сначала он проверяет новый код на ошибки, а уже затем делает сборку. Сборка происходит на уровне изображений `Docker`, которые отправляются в реестр (в данном случае Dockerhub). Последующие шаги не реализованы, но все что там происходит - это использование собранных изображений уже на сервере

6. Процессы

Учитывая что наше приложение приложение - это просто REST сервис, то никакие данные состояний не хранятся

7. Привязка портов

Выполнен внутри файлов `docker-compose`, где указаны порты, где будет работать приложение и куда оно будет перенаправлено. Дальнейшие шаги могут включить добавление обратного прокси (reverse proxy) как `nginx` для дальнейшего перенаправления портов

8. Параллелизм

В данном случае нет необходимости добавлять другие процессы по типу фоновая задача, поскольку приложение выполняет только одну задачу - веб-процесс для обработки HTTP-запросов. Говоря о горизонтальном масштабировании он может быть осуществлен с помощью Kubernetes на уровне контейнеров или при помощи увеличения количества работников (workers)

9. Утилизируемость

В случае использования Kubernetes контейнеры будут сменять друг друга в случае пробемы одной из них. В данном случае некоторые аспекты утилизируемости осуществлены с помощью `Gunicorn`

10. Паритет разработки/работы приложения

Разработка (development) и работа (production) приложения схожы по всем пунктам кроме запуска, который в разработке реализован с помощью команды самого `Django` - `python manage.py runserver`, а в случае работы он осуществлен с помошью `Gunicorn`. Другие различия связаны с присутствием в релизе обслуживания статических файлов и указания названия изображения для последующей ее выгрузки в реестр

11. Журналирование

Журналирование может быть доступно с помощью команды самого `Docker`-а `docker-compose logs`, который покажет события со всех контейнеров. Решения в релизе будут включать сторонние сервисы как `Sentry`

12. Задачи администрирования

Эти задачи выполняются один раз при запуске приложения в конце файлов `Dockerfile` при помощи команды `ENTRYPOINT`, которые указывают на файлы `entrypoint`. Эти задачи включают в себя миграцию датабазы для разработки и релиза, а также сбор статических файлов в случае релиза. 

Стоит упомянуть что эти статические файлы не обслуживаются, потому что они показаны для демонстрации разницы между разработкой и релизом

## Предложения по улучшению

1. Алгоритм

Алгоритм демонстрирует плохие результаты и требует доработки. Разработаная модель ищет только поверхностные сходства между данными ввода и вывода. Чтобы найти более глубокую связь между ними нужно использовать другую модель, к примеру модель глубокого обучения с несколькими слоями. 

Также алгоритм можно улучшить на стадии препроцессинга входных данных. К примеру можно лучше "очистить" текста отзывов, чтобы часто повторяющиеся или неважные слова были удалены.

К тому же для получения более точной модели необходимо намного больше набора данных

2. Django Приложение

Все предложение по улучшению приложения связаны с стадией релиза. Многие технологии не были использованы, поскольку стадия релиза не была осуществлена. При настоящем релизе CI/CD инструмент будет доводить собранный код до релиза, где за ним нужно поставить полноценный инструмент журналирования. Данный код готов для последующего масштабирования